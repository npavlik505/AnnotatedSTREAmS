#! /usr/bin/python3
print("RUNNING PYTHON VERSION")

# libstreams is a python library that is generated by f2py build routines in
# the apptainer build pipeline. If you change anything in the fortran code, you
# must rebuild libstreams with f2py before the changes are reflected in the python 
# code
import libstreams as streams 
# we have to start MPI here before importing the mpi4py library
# otherwise, there will be an error in the streams code when they attempt to 
# initialize
streams.wrap_startmpi()

from mpi4py import MPI
import json

import io_utils
import numpy as np
from config import Config
import utils

#
# initialize some global variables
#
import globals
globals.init()
from globals import rank, comm

#
# Load in config, initialize
#

with open("/input/input.json", "r") as f:
    json_data = json.load(f)
    config = Config.from_json(json_data)

#
# allocate arrays so we dont need to reallocate in the solver loop
#
span_average = np.zeros([5, config.nx_mpi(), config.ny_mpi()], dtype=np.float64)
temp_field = np.zeros((config.nx_mpi(), config.ny_mpi(), config.nz_mpi()), dtype=np.float64)

#
# execute streams setup routines
#

streams.wrap_setup()
streams.wrap_init_solver()

# initialize files

#
# Initialize datasets and HDF5 output files
#
flowfields = io_utils.IoFile("/distribute_save/flowfields.h5")

grid_shape = [config.grid.nx, config.grid.ny, config.grid.nz]
span_average_shape = [config.grid.nx, config.grid.ny]

numwrites = int(config.temporal.num_iter / config.temporal.span_average_io_steps)

velocity_dset = io_utils.VectorField3D(flowfields, [5, *grid_shape], 1, "velocity", rank)
span_average_dset = io_utils.VectorFieldXY2D(flowfields, [5, *span_average_shape], numwrites, "span_average", rank)
shear_stress_dset = io_utils.ScalarFieldX1D(flowfields, [config.grid.nx], numwrites, "shear_stress", rank)

#
# Main solver loop, we start time stepping until we are done
#
for i in range(config.temporal.num_iter):
    #print(f"step {i}")
    streams.wrap_step_solver()

    if (i % config.temporal.span_average_io_steps) == 0:
        utils.hprint("writing span average to output")
        streams.wrap_copy_gpu_to_cpu()
        streams_data_slice = config.slice_flowfield_array(streams.mod_streams.w)
        utils.calculate_span_averages(config, span_average, temp_field, streams_data_slice)

        span_average_dset.write_array(span_average)

        # also write shear stress information
        streams.wrap_tauw_calculate()
        shear_stress_dset.write_array(streams.mod_streams.tauw_x)

# writes the full array out to as the final exit condition
streams.wrap_copy_gpu_to_cpu()
velocity_dset.write_array(config.slice_flowfield_array(streams.mod_streams.w))

#
# wrap up execution of solver
#

streams.wrap_finalize_solver()

print("finalizing solver")
streams.wrap_finalize()
